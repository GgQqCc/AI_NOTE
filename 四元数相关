Omniverse (整体生态系统)
Carbonite (最底层的 C++框架/核心) 1、屏蔽底层差异2插件管理3基础功能库【文件访问、日志记录、内存多线程、输入输出】
提供了一套标准（如 USD 格式）和连接服务（如 Nucleus 数据库），让不同的人在不同的软件（Maya, Blender, Isaac Sim）里可以同时协作
包含内容：它包含了 Nucleus（存储）、Connectors（插件）、以及各种成品应用（如 Isaac Sim, Create, Machinima）
Omniverse Kit (核心引擎/开发工具包)
Isaac Sim  其实就是一个运行在 Omniverse Kit 之上的特定插件集
渲染 (RTX Renderer)
物理 (PhysX)
UI 框架 (Omni.ui)
逻辑控制 (Action Graph，也就是你说的 ROS_graph)
SDK（库+工具+API）
打开 Isaac Sim 时：你其实是在运行 Omniverse Kit，并加载了 Isaac 相关的插件
Property 面板改参数时：在操作 USD (Universal Scene Description) 数据结构
ROS_graph 连线时：使用 Kit 提供的视觉化逻辑引擎
找不到某个功能时：有时候不属于 Isaac Sim，而是属于底层的 Omniverse Kit（比如窗口管理、基础渲染设置）。
可以跳过图形界面直接接触底层Kit引擎

OpenUSD：3D文件格式&3D场景描述引擎，包含机器人的3D模型，物理属性（质量、摩擦力）、关节约束（旋转轴、限位）和传感器配置。
分层编辑（Layers）：有一个“原始机器人.usd”，然后创建一个“场景.usd”引用它。你在场景里给机器人改了颜色或加了一个传感器，这些改动会存在新的层里，不会破坏原始文件。
可以多人同时通过 Omniverse Nucleus 编辑同一个 USD 场景，就像多个人同时编辑一个Google Doc一样
Property（属性）面板 或 Stage（场景树）就是 操作OpenUSD
Prim（基本单元）：Stage 里的每一个节点（一个球、一个机器人、一个坐标系）都叫一个 Prim。
Attribute（属性）：Prim 上的具体数值，比如 xformOp:translate（位置）。
Relationship（关系）：Prim 之间的逻辑连接。注意：你的 ROS_graph (Action Graph) 里的连线，本质上就是在 USD 里建立一种特定的 Relationship。
Schema（架构）：USD 规定了不同物体的结构。比如“机器人架构”规定了必须有关节和刚体。

Fabric 内存中运行的高速数据层
工作逻辑：启动仿真时，系统会把 USD 中的关键数据（比如机器人的位置、关节角度、传感器数值）“拉取”到 Fabric 内存中。
物理引擎 (PhysX) 和 ROS_graph (Action Graph) 直接在 Fabric 上读写数据，速度极快。
传统读取更新太慢


Omni.physx负责从 USD 和 Fabric 中解析数据，将这些数据写入 PhysX，运行仿真，并将仿真输出写回 USD 或 Fabric。

你给一个物体添加“物理特性”时，你实际上是在给这个 USD Prim 应用不同的 Schema（架构/模式）
UsdPhysics Schema行业标准接口
Rigid Body (刚体)：这个物体是否受重力影响？
Collision (碰撞体)：这个物体的外壳形状是什么？
Mass (质量)：它有多重？重心在哪里？
Joints (关节)：基础的旋转（Revolute）、平移（Prismatic）关节定义
PhysX Schema (NVIDIA 特有增强)
Solver Iterations (解算器迭代次数)：决定了物理计算的精度（比如防止关节乱抖）。
Contact Offsets (接触偏移)：两个物体靠多近算碰撞？
Materials (物理材质)：更精细的静摩擦、动摩擦、恢复系数（弹性）。
Articulation Root：这是 Isaac Sim 机器人最核心的组件，专门用于处理多链路的高性能仿真
Tendon (腱)：模拟机器人的钢丝传动


处理旋转逻辑的核心数学工具
四元数、欧拉角、旋转矩阵
欧拉角：旋转拆解为绕三个相互垂直轴（X, Y, Z）的连续三次旋转，直观+存储小（三个浮点数）  
万向节锁 (Gimbal Lock)：如某个轴旋转90度，另外两个轴重合丢失一个自由度。  飞机垂直向上，偏航和翻滚看起来一样的。
插值困难： 两个欧拉角状态之间做平滑过渡非常困难，容易产生奇怪抖动
顺序相关：XYZ 旋转和 ZYX 旋转得到的结果完全不同，容易产生歧义

本质：欧拉角的数值空间与实际的物理旋转空间不是“线性映射”的关系
欧拉角是将旋转拆分为绕 X, Y, Z 三个轴的分步动作。比如先x再y再z,这种轨迹在仿真中看起来就像是姿态在抖动或摆动
当你对三个角度同时进行线性插值（即让三个数字各自均匀变化）时，物体在空间中并不是沿着两点之间最短的路径转动。
（插值）线性改变角度，会先快后慢或者波动。
万向节锁附近奇异性
数值跳变： 在这个区域，为了实现一个微小的物理旋转，欧拉角的数值可能需要发生剧烈的跳变（例如从 +179circ 跳到 -179circ）。
插值灾难： 如插值算法简单地在 +179circ 和 -179circ 之间取平均值，会经过 0circ，导致机器人突然反向旋转一整圈。这就是你在仿真中经常看到的“疯狂打转”现象。

旋转矩阵  映射逻辑
 3* 3 的矩阵来表示一个坐标系相对于另一个坐标系的基向量映射。矩阵的每一列其实就是旋转后坐标轴在原坐标系中的方向。 齐次变换阵的左上角3*3  右上角是X Y Z的位移 。参数多 9个
 劣势：经过成千上万次乘法运算后，由于浮点误差，矩阵会失去“正交性”（即它可能开始包含缩放或切变）。修复一个旋转矩阵（正交化）需要复杂的施密特正交化计算。
 
 
四元数：4个参数，运动平滑性高
三个虚数ijk,
q = w + xi + yj + zk
因：四元数存在于四维单位球面上
球面线性插值 (Slerp)：保证旋转沿着大圆路径（Great Circle Path），恒定角速度、最短路径。

普通线性插值是lERP 两个点之间拉直线，
修复它极度简单——只需除以它的模长 ||q|| 即可。这种归一化（Normalization）计算量极小，能保证仿真长久运行不出错
显存友好 节省gpu显存带宽
缺： 无法直接表示“非旋转”变换。不能表示平移、缩放或投影变换。 Isaac Sim 底层的齐次变换阵中，旋转部分可以用四元数表示，但整个空间变换仍需依赖 4 * 4 矩阵。
调试困难，数字抽象。
底层、神经网络用四元数
标定用齐次阵旋转矩阵
配置文件用欧拉角


欧拉角：拓扑死角
IK 中： 如果你的目标姿态接近这个锁死点，雅可比矩阵（Jacobian）会变得奇异（Singular），它的逆矩阵不存在。IK 算法为了强行达到目标，会计算出异常巨大的关节角度变化，导致仿真中的机器人“瞬间爆炸”或剧烈抖动。
四元数的优势：四元数使用 4 个参数在单位超球面（S^3）上描述旋转。这个超球面是连续且闭合的，没有任何边界或重叠。在 IK 中： 无论机器人怎么转，四元数到旋转空间的映射始终是平滑的。它没有“万向节锁”这种数学上的死角，因此雅可比矩阵在描述旋转变化时不会因为坐标定义问题而降阶

特别说明：数学奇异 vs 物理奇异
我们需要区分两个概念，这在 Isaac Sim 5.1.0 开发中很重要：
数学表示奇异（Representation Singularity）： 这是由于用欧拉角描述旋转引起的。使用四元数可以完全消除这种崩溃。
物理奇异（Workspace Singularity）： 这是由于机器人手臂完全伸直，或者关节达到了极限。这是物理结构的限制，四元数无法消除它。
总结： 四元数通过在四维超球面上运算，确保了旋转的“描述语言”永远不会出现逻辑断层。即使机器人处于物理奇异位形，四元数依然能提供一个确定的方向，而不是让计算引擎因为“除以零”而崩溃
IK 求解本质上是在缩小“当前姿态”与“目标姿态”之间的误差。








